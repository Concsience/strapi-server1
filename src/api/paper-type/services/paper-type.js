/**
 * paper-type service - TypeScript implementation
 * Business logic for paper type and material management
 * Follows official Strapi TypeScript documentation patterns
 */
const { factories } = require('@strapi/strapi');
module.exports = factories.createCoreService('api::paper-type.paper-type', ({ strapi }) => ({
    /**
     * Find paper types with business logic enhancements
     */
    async findWithBusinessLogic(params = {}) {
        try {
            // Add default business rules
            const enhancedParams = {
                ...params,
                filters: {
                    ...params.filters,
                    publishedAt: { $notNull: true },
                    // Only show paper types with valid pricing
                    paper_price_per_cm_square: { $gt: 0 }
                }
            };
            const results = await strapi.documents('api::paper-type.paper-type').findMany(enhancedParams);
            // Enhance results with calculated fields
            const enhancedPaperTypes = await Promise.all(results.results.map(async (paperType) => {
                const usageCount = await this.getPaperTypeUsageCount(paperType.documentId);
                const revenue = await this.getPaperTypeRevenue(paperType.documentId);
                return {
                    ...paperType,
                    usageCount,
                    revenue: Math.round(revenue * 100) / 100,
                    isPopular: usageCount >= 10,
                    priceCategory: this.getPriceCategory(paperType.paper_price_per_cm_square || 0),
                    costEfficiency: this.calculateCostEfficiency(paperType.paper_price_per_cm_square || 0)
                };
            }));
            return {
                ...results,
                results: enhancedPaperTypes
            };
        }
        catch (error) {
            strapi.log.error('Error in findWithBusinessLogic:', error);
            throw error;
        }
    },
    /**
     * Get paper type usage count across cart and order items
     */
    async getPaperTypeUsageCount(paperTypeId) {
        try {
            const [cartItemCount, orderItemCount] = await Promise.all([
                strapi.documents('api::cart-item.cart-item').count({
                    filters: { paper_type: { documentId: paperTypeId } }
                }),
                strapi.documents('api::ordered-item.ordered-item').count({
                    filters: { paper_type: { documentId: paperTypeId } }
                })
            ]);
            return cartItemCount + orderItemCount;
        }
        catch (error) {
            strapi.log.error('Error getting paper type usage count:', error);
            return 0;
        }
    },
    /**
     * Calculate total revenue generated by paper type
     */
    async getPaperTypeRevenue(paperTypeId) {
        try {
            const orderedItems = await strapi.documents('api::ordered-item.ordered-item').findMany({
                filters: {
                    paper_type: { documentId: paperTypeId }
                },
                fields: ['total_price'],
                pagination: { pageSize: 1000 }
            });
            const totalRevenue = orderedItems.results.reduce((sum, item) => sum + (parseFloat(item.total_price || '0') || 0), 0);
            return totalRevenue;
        }
        catch (error) {
            strapi.log.error('Error calculating paper type revenue:', error);
            return 0;
        }
    },
    /**
     * Get price category for paper type
     */
    getPriceCategory(price) {
        if (price <= 0)
            return 'invalid';
        if (price < 0.10)
            return 'economy';
        if (price < 0.25)
            return 'standard';
        if (price < 0.50)
            return 'premium';
        if (price < 1.00)
            return 'luxury';
        return 'ultra-premium';
    },
    /**
     * Calculate cost efficiency score
     */
    calculateCostEfficiency(price) {
        // Simple efficiency score based on price (lower is more efficient)
        // Normalized to 0-100 scale where 100 is most efficient
        const maxPrice = 2.00; // Assumed maximum reasonable price
        const efficiency = Math.max(0, 100 - (price / maxPrice) * 100);
        return Math.round(efficiency);
    },
    /**
     * Get popular paper types based on usage and revenue
     */
    async getPopularPaperTypes(limit = 10) {
        try {
            const paperTypes = await strapi.documents('api::paper-type.paper-type').findMany({
                filters: {
                    publishedAt: { $notNull: true },
                    paper_price_per_cm_square: { $gt: 0 }
                },
                pagination: { pageSize: limit * 2 } // Get more to filter and sort
            });
            // Calculate popularity metrics for each paper type
            const paperTypesWithMetrics = await Promise.all(paperTypes.results.map(async (paperType) => {
                const usageCount = await this.getPaperTypeUsageCount(paperType.documentId);
                const revenue = await this.getPaperTypeRevenue(paperType.documentId);
                return {
                    id: paperType.id,
                    paper_names: paperType.paper_names || 'Unknown',
                    paper_price_per_cm_square: paperType.paper_price_per_cm_square || 0,
                    usageCount,
                    revenue: Math.round(revenue * 100) / 100,
                    priceCategory: this.getPriceCategory(paperType.paper_price_per_cm_square || 0)
                };
            }));
            // Sort by usage count and revenue, filter popular ones
            const popularPaperTypes = paperTypesWithMetrics
                .filter(paperType => paperType.usageCount > 0) // Only used paper types
                .sort((a, b) => {
                // Primary sort: usage count
                if (b.usageCount !== a.usageCount) {
                    return b.usageCount - a.usageCount;
                }
                // Secondary sort: revenue
                return b.revenue - a.revenue;
            })
                .slice(0, limit);
            return {
                results: popularPaperTypes,
                pagination: {
                    page: 1,
                    pageSize: limit,
                    total: popularPaperTypes.length
                }
            };
        }
        catch (error) {
            strapi.log.error('Error getting popular paper types:', error);
            throw error;
        }
    },
    /**
     * Get comprehensive paper type statistics
     */
    async getPaperTypeStats() {
        try {
            // Basic counts
            const totalCount = await strapi.documents('api::paper-type.paper-type').count();
            const publishedCount = await strapi.documents('api::paper-type.paper-type').count({
                filters: {
                    publishedAt: { $notNull: true }
                }
            });
            // Price statistics
            const paperTypesWithPricing = await strapi.documents('api::paper-type.paper-type').findMany({
                filters: {
                    publishedAt: { $notNull: true },
                    paper_price_per_cm_square: { $gt: 0 }
                },
                fields: ['paper_price_per_cm_square'],
                pagination: { pageSize: 1000 }
            });
            let averagePrice = 0;
            let minPrice = 0;
            let maxPrice = 0;
            if (paperTypesWithPricing.results.length > 0) {
                const prices = paperTypesWithPricing.results.map(pt => pt.paper_price_per_cm_square || 0);
                averagePrice = prices.reduce((sum, price) => sum + price, 0) / prices.length;
                minPrice = Math.min(...prices);
                maxPrice = Math.max(...prices);
            }
            // Usage statistics
            const [totalCartItems, totalOrderItems] = await Promise.all([
                strapi.documents('api::cart-item.cart-item').count(),
                strapi.documents('api::ordered-item.ordered-item').count()
            ]);
            // Revenue calculation
            const orderItems = await strapi.documents('api::ordered-item.ordered-item').findMany({
                fields: ['total_price'],
                pagination: { pageSize: 1000 }
            });
            const totalRevenue = orderItems.results.reduce((sum, item) => sum + (parseFloat(item.total_price || '0') || 0), 0);
            // Most popular paper type
            const popularPaperTypes = await this.getPopularPaperTypes(1);
            const mostPopular = popularPaperTypes.results[0] || null;
            return {
                totalPaperTypes: totalCount,
                publishedPaperTypes: publishedCount,
                averagePrice: Math.round(averagePrice * 1000) / 1000,
                mostPopular,
                priceRange: {
                    min: Math.round(minPrice * 1000) / 1000,
                    max: Math.round(maxPrice * 1000) / 1000
                },
                usageStats: {
                    totalCartItems,
                    totalOrderItems,
                    totalRevenue: Math.round(totalRevenue * 100) / 100
                }
            };
        }
        catch (error) {
            strapi.log.error('Error getting paper type stats:', error);
            throw error;
        }
    },
    /**
     * Search paper types with advanced filters
     */
    async searchPaperTypes(searchTerm, options = {}) {
        try {
            const { minPrice, maxPrice, priceCategory, popular, limit = 25 } = options;
            const filters = {
                publishedAt: { $notNull: true },
                paper_names: { $containsi: searchTerm }
            };
            // Add price filters
            if (minPrice || maxPrice) {
                filters.paper_price_per_cm_square = {};
                if (minPrice)
                    filters.paper_price_per_cm_square.$gte = minPrice;
                if (maxPrice)
                    filters.paper_price_per_cm_square.$lte = maxPrice;
            }
            const results = await strapi.documents('api::paper-type.paper-type').findMany({
                filters,
                sort: 'paper_names:asc',
                pagination: { page: 1, pageSize: limit }
            });
            // Post-process results
            let filteredResults = results.results;
            // Filter by price category
            if (priceCategory) {
                filteredResults = filteredResults.filter(paperType => this.getPriceCategory(paperType.paper_price_per_cm_square || 0) === priceCategory);
            }
            // Enhance results
            const enhancedResults = await Promise.all(filteredResults.map(async (paperType) => {
                const usageCount = popular ? await this.getPaperTypeUsageCount(paperType.documentId) : 0;
                return {
                    ...paperType,
                    usageCount,
                    priceCategory: this.getPriceCategory(paperType.paper_price_per_cm_square || 0),
                    isPopular: usageCount >= 10
                };
            }));
            // Filter popular if requested
            if (popular) {
                filteredResults = enhancedResults.filter(paperType => paperType.isPopular);
            }
            return {
                results: popular ? filteredResults : enhancedResults,
                pagination: {
                    ...results.pagination,
                    total: filteredResults.length
                }
            };
        }
        catch (error) {
            strapi.log.error('Error searching paper types:', error);
            throw error;
        }
    },
    /**
     * Validate paper type data before create/update
     */
    validatePaperTypeData(data) {
        const errors = [];
        if ('paper_names' in data && data.paper_names) {
            if (data.paper_names.length < 2) {
                errors.push('Paper name must be at least 2 characters long');
            }
            if (data.paper_names.length > 100) {
                errors.push('Paper name must be less than 100 characters');
            }
        }
        if ('paper_price_per_cm_square' in data && data.paper_price_per_cm_square !== undefined) {
            if (data.paper_price_per_cm_square <= 0) {
                errors.push('Paper price per cm² must be positive');
            }
            if (data.paper_price_per_cm_square > 10) {
                errors.push('Paper price per cm² seems too high (max 10€)');
            }
        }
        return errors;
    },
    /**
     * Calculate price impact for artwork
     */
    async calculatePriceImpact(paperTypeId, artworkWidth, artworkHeight) {
        try {
            const paperType = await strapi.documents('api::paper-type.paper-type').findOne({
                documentId: paperTypeId
            });
            if (!paperType || !paperType.paper_price_per_cm_square) {
                throw new Error('Paper type not found or has no pricing');
            }
            const area = artworkWidth * artworkHeight;
            const paperCost = area * paperType.paper_price_per_cm_square;
            return {
                paperType: {
                    id: paperType.id,
                    name: paperType.paper_names,
                    pricePerCmSquare: paperType.paper_price_per_cm_square,
                    category: this.getPriceCategory(paperType.paper_price_per_cm_square)
                },
                calculation: {
                    area,
                    paperCost: Math.round(paperCost * 100) / 100,
                    costPercentage: 0 // Would need artwork base price to calculate
                }
            };
        }
        catch (error) {
            strapi.log.error('Error calculating price impact:', error);
            throw error;
        }
    }
}));
